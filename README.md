# MERN-Stack
Learning and Exploring MERN stack


MERN stands for MongoDB, Express, React, Node, after the four key technologies that make up the stack.

MongoDB - document database
Express(.js) - Node.js web framework
React(.js) - a client-side JavaScript framework
Node(.js) - the premier JavaScript web server

![image](https://user-images.githubusercontent.com/67750918/182497123-6b7282a0-7fa5-4442-9658-6f43028cdf21.png)

The middle (application) tier is made up of Express and Node. Node.js is a popular and capable JavaScript server platform, while Express.js is a server-side web framework. Regardless of the form you pick, ME-(RVA)-N is the best method to work with JavaScript and JSON from start to finish.

## How does the MERN stack work?

The MERN stack's top layer is React.js, a declarative JavaScript framework for developing dynamic client-side HTML applications. React allows you to create sophisticated interfaces by connecting basic Components to data on your backend server and rendering them as HTML.

### React.js Front End

React excels at managing stateful, data-driven interfaces with minimum code and suffering, and it includes all the bells and whistles you'd expect from a modern web framework: outstanding support for forms, error handling, events, lists, and more.

### Express.js and Node.js Server Tier

The Express.js server-side framework, which runs within a Node.js server, is the next level below. Express.js touts itself as a "fast, unopinionated, simple Node.js web framework," and that is precisely what it is. Express.js has robust models for URL routing (which matches an incoming URL with a server function) and managing HTTP requests and answers.

You may connect to Express.js functions that power your application by sending XML HTTP Requests (XHRs), GETs, or POSTs from your React.js front-end. These methods, in turn, leverage MongoDB's Node.js drivers to access and update data in your MongoDB database, either via callbacks or Promises.

### MongoDB Database Tier

If your application maintains data (user profiles, content, comments, uploads, events, and so on), you'll need a database that's as simple to use as React, Express, and Node.

That's where MongoDB comes in: JSON documents generated by your React.js front end may be transmitted to the Express.js server, where they can be processed and (if valid) saved straight in MongoDB for subsequent retrieval. Again, if you're working on the cloud, Atlas is a good place to start. Continue reading if you want to put up your own MERN stack!

So, lets get started with setting up the Environment
------

To get started, you will need to do the following:
- **Install Node**
    - To install Node, go to https://nodejs.org/en/ and download either the LTS version or the current version.

- **Have or Install a Code Editor**
    - You can use any code editor of your choice for this tutorial. However, for the sake of demonstration, we will be using VS Code editor with the plugin prettier and vscode icons.

MERN enables us to build full-stack solutions. So, in order to fully realise its potential, we will develop a MERN stack project. We will develop both a back end and a front end for this project. The front end will be built with React, while the back end will be built with MongoDB, Node, and Express. We shall refer to the front end client and the back end server.

## What is NodeJS?

- ​ A JavaScript Runtime Environment 
- ​ Built on Chrome's V8 Engine! 

- ​ Light, scalable and open-source language platform 

- ​ Used for Server-side development

- ​ Since we use Javascript in both the frontend and backend the development will be much faster.

Hello World in NodeJS
------
1. Create a file - helloworld.js
```Javascript 
console.log(“Hello World”);
```
2. And save the file after adding this line
3. Run the file - `node helloworld.js`

NodeJS in-built package
------
- Modules are the blocks of encapsulated code that communicates with an external application on the basis of their related functionality. 

- Modules can be a single file or a collection of multiples files/folders. 

-  The reason programmers are heavily reliant on modules is because of their re-usability as well as the ability to break down a complex piece of code into manageable chunks.

Modules are of three types:
------
- ->Core Modules
- ->Local Modules
- ->Third-party Modules

Core Modules:
------
**Syntax:**

`var module=require('module_name');`

 local modules are created locally in your Node.js application

The require() function will return a JavaScript type depending on what the particular module returns. The following example demonstrates how to use the Node.js Http module to create a web server.
```Javascript
var http = require('http');
http.createServer(function (req, res) {
res.writeHead(200, {'Content-Type': 'text/html'});
res.write('Welcome to this page!');
res.end();
}).listen(3000);
```

 **The following list contains some of the important core modules in Node.js:**
![image](https://user-images.githubusercontent.com/67750918/182500723-757b315d-9627-46ba-80c2-4a0b6d27669f.png)

-------
Local Module:
------
- Local modules are modules created locally in your Node.js application. 

- These modules include different functionalities of your application in separate files and folders. 

- The module.exports is a special object which is included in every JS file in the Node.js application by default. Use module.exports or exports to expose a function, object or variable as a module in Node.js.

- The require() function returns a log object because logging module exposes an object using module.exports
- - - - - 
Let’s create a simple calculating module that calculates various operations. Create a calculator.js file that has the following code:

*FileName: Calculator.js*
```Javascript
exports.add = function (x, y) {
	return x + y;
};
	
exports.sub = function (x, y) {
	return x - y;
};
	
exports.mult = function (x, y) {
	return x * y;
};
	
exports.div = function (x, y) {
	return x / y;
};
```
Since this file provides attributes to the outer world via exports, another file can use its exported functionality using the require() function.

*FileName: index.js*
``` Javascript
var calculator = require('./calc');
	
var x = 50, y = 10;
	
console.log("Addition of 50 and 10 is "
				+ calculator.add(x, y));
	
console.log("Subtraction of 50 and 10 is "
				+ calculator.sub(x, y));
	
console.log("Multiplication of 50 and 10 is "
				+ calculator.mult(x, y));
	
console.log("Division of 50 and 10 is "
				+ calculator.div(x, y));

```

Step to run this program: Run index.js file using the following command:
```
node index.js
Output:

Addition of 50 and 10 is 60
Subtraction of 50 and 10 is 40
Multiplication of 50 and 10 is 500
Division of 50 and 10 is 5
```
Third-party Modules
------
- Node 3rd party modules is a module or package which is developed and manitained by 3rd parties.

- Millions of 3rd party node modules/packages which are freely available on NPM Registry.

- You can install node 3rd party modules/packages and use them to add functionality to your projects.

- Node 3rd party modules can be installed using NPM (Node Package Manager).

*Example:*
```Javascript
npm install express
npm install mongoose
```

NPM
(Node Packet Manager)
------
npm is the Node JavaScript platform's package management. It instals modules so that nodes can locate them and intelligently resolves dependency issues. It is highly customizable to serve a wide range of use cases. It is most widely used for publishing, discovering, installing, and developing node applications.
Default package manager for the Node.js environment, makes it easier for a developer to publish and share the source code of Node.js packages npm can manage dependencies.

npm can (in one command line) install all the dependencies of a project.
Dependencies are also defined in package.json.

## Synchronous & Asynchronous programming

Synchronous
------
Synchronous, in general, means one at a time.
Synchronous is the sequential flow of program execution in a programming
context.

The program/code will be read in sequence from top to bottom and
executed line by line, with one thing getting executed at a time.
The Javascript engine waits for the code to get executed completely before
moving to the next line.
So Synchronous programming executes each line of code at a time in a
sequence

Example:
```Javascript
	console.log('Hi');
	function greet(){
	 console.log('Welcome to
	Grandline');
	}
	greet();
	// Hi
	// Welcome to Grandline
```
Asynchronous
------
Asynchronous, in general, is not occurring at the same time. 
Asynchronous in a programming context is the execution of code/function without waiting for the other code/functions to execute. 
This enables the Javascript engine to execute the code without halting the code execution process

In Javascript, there are different ways to achieve asynchronous execution.

Callbacks:

We need to note that Callbacks are used inside Browser API/Web API functions or events.
These APIs internally accept callback functions to achieve asynchronous programming. They have
methods such as setTimeout and event handlers like click, mouse over, scroll, etc.

Callbacks are functions that are passed as arguments to other functions and
then invoked in the outer function to perform its operation.
Also, callbacks take time to execute and are not executed immediately; they
are passed at first and are invoked later.

Callbacks should be implemented asynchronously. Else the event loop in the
JS engine has to wait until the callback is executed, which may cause
undesired output, or our program may become unresponsive.

```Javascript
	function greet(callbackFn){
	 callbackFn();
	 console.log('Welcome to
	Grandline');
	}
	greet(function(){
	 console.log('Hi')
	});
	// Hi
	// Welcome to Grandline
```

```Javascript
	// Same code with arrow syntax
	function greet(callbackFn){
	 callbackFn();
	 console.log('Welcome to
	Grandline');
	}
	greet(() => console.log('Hi'));
	// Hi
	// Welcome to Grandline
```

Call Stack
------

Call Stack is the stack data structure maintained by the Javascript engine. It
operates in a LIFO manner (Last in First Out). It has the purpose of tracking
the current function being executed. Call Stack is also known as Function
execution stack.

When the Javascript engine runs the code, the first thing that happens
is an execution context is created precisely Global Execution Context
(GEC) whenever the code execution is started.
- So the first thing that’s pushed into the call stack is GEC.
- After the execution of code, the execution context is popped out.
- Remember, each function has its execution context.
-Execution context is the environment in which the code is executed
Example:
```Javascript
	function greet(){
	 return function() {
	 console.log('Welcome to Grandline');
	 }
	}
	const result = greet();
	result(); // Welcome to Grandline
```

Callback queue
------

Callback functions do not enter the call stack for execution directly instead a
callback function is registered in the Web API and then the result of callback
is stored now the callback is entered to Callback Queue. 

It is a queue data structure that has entries in FIFO manner (First in First out) and stores all
the callback functions ready for execution and once the call stack is empty
they are deleted from the queue and pushed to the stack for execution

Callbacks with Async Example:
```javascript
console.log('Hi');
function callback(){
 console.log('Welcome to Grandline');
}
setTimeout(callback, 2000);
console.log('Join our Pirate Crew & be our Nakama');
// Hi
// Join our Pirate Crew & be our Nakama
// Welcome to Grandline (with a delay of 2 seconds)

```
CallBacks hell
------

- It is a common scenario to have nested callbacks and all the
nested callbacks will wait inside the callback queue and be pushed to the call stack in
FIFO manner (First in First out).
- This complex nesting of callbacks makes our code difficult to maintain and debug.
- It is also prone to more errors if not written carefully.
- This scenario in which we have complex nested callbacks is referred to as Callback hell.
Here, each callback takes arguments that are the result of previous callbacks.
- This kind of callback structure forms a pyramid like structure

Example
```Javascript
	// Callbacks hell example
	function cheese(){
	 console.log('Add lots of cheese');
	}
	function patty(cheese){
	 console.log('Add veggies and patties');
	 cheese();
	}
	function bun(patty){
	 console.log('Take two fresh buns');
	 patty(cheese);
	}
	function burger(bun){
	 setTimeout(() => {
	 bun(patty);
	 console.log('Our Burger is ready');
	 }, 2000);
	}
	burger(bun);
	console.log('Lets make a Burger');
	
	//Output:
	
	// Lets make a Burger// (after delay of 2000ms)
	// Take two fresh buns
	// Add veggies and patties
	// Add lots of cheese
	// Our Burger is ready
```
Timers in JS
------
In Javascript there are two Timing Events:
● setTimeout()
● setInterval()

setTimeout()
------

setTimeout(): It is basically a function that is used to execute a function or code after a specified delay.
`Syntax: setTimeout(function, milliseconds, args)`
Example:
```javascript
	function burger(){
	 setTimeout(() => {
	 console.log('Our Burger
	is ready');
	 }, 2000);
	}
	burger();
	// (after delay of 2 seconds)
	// Our Burger is ready
```
clearTimeout()
------

clearTimeout() is the method used to cancel/clear the timeout even before it is
executed.
- It accepts the variable to which we assign the setTimeout(). This variable
returns the reference of setTimeout(). Here we use clearTimeout(getFood)
with getFood variable.
- It does not clear/cancel the delay in the setTimeout it actually cancels the
setTimeout() event itself.
```javascript
	const getFood = setTimeout((food) => {
	 console.log('Our ' + food +' is ready');
	}, 2000, 'Pizza');
	clearTimeout(getFood);
	// Nothing happens and code just exits
```

setInterval()
------
setInterval(): It is basically a function that is used to execute a function or code repeatedly after a
specified interval of time.
`Syntax: setInterval(function, milliseconds, args)`
Example:
```javascript
	setInterval((food) => {
	 console.log('Our ' + food +' is ready');
	}, 2000, 'Pizza');
	// Gets logged every 2 seconds
	// Our Pizza is ready
	// Our Pizza is ready
	// Our Pizza is ready
	// Our Pizza is ready
	// Our Pizza is ready
	// ^C
```
clearInterval()
------
clearInterval() is the method used to stop/clear the interval.
- It accepts the variable more precisely intervalID to which we assign the
setInterval(). Here we use clearInterval(getFood) with getFood variable to stop
the setInterval().
- It does not clear the delay in the setInterval. It actually stops the setInterval()
event itself before execution

```Javascript
	const getfood = setInterval((food) => {
	 console.log('Our ' + food +' is ready');
	}, 2000, 'Pizza');
	clearInterval(getfood);
	// Nothing happens and code just exits
```
Promises: 
Promises are objects in JS that let us perform asynchronous operations.

An object that represents the
completion (or failure) of an
asynchronous operation and also its
resulting value is known as a promise.
```javascript
	const newPromise= new Promise((resolve, reject)=>{
	console.log("Promise created");
	setTimeout() => {
	reject ("Some Error");
	), 1000); //reject after 1 sec

	console.log("Exit from promise")
	});

	console.log("First txt in sync");
	
	newPromise
	.then((result) => {
	console.log("success: ", result);
	})
	.catch((error) => { 
	console.log("Faliure:", error);
	})
	.finally (() => {
	console.log("Promise completed");
	});
	
	console.log("Last txt sync");
```
## Promise Hell

Promise hell is a self created
problem due to lack of
understanding of Promises,
unlike callback hell. In Promise
hell as well we have to wait for
other promises to return and it
will fill the stack.
```javascript
	fetchStory()
	.then((story) => { return findText (story);
	})
	.then((txt) => {
	return print (txt);
	});

	//single liners
	fetchStory (
	.then((story) => findText (story))
	.then((txt) => print(txt));

	// inline
	fetchStory()
	.then (findText)
	.then (print);
```
## Async/Await: 

Async Await keywords were introduced in Javascript in ECMAScript 2017. This made
asynchronous programming easier and is considered a better alternative to promises

Async/ Await is used to handle promises in
synchronous code fashion with less code
effort.

Async: We put this keyword before any
function then, it will return a promise.

Await: This keyword is used before a promise
inside the Async block to block the code until
promise resolves or reject.

So, these keyword helps us to get write a
synchronous fashion code with cleaner syntax.

Example:
```Javascript
const first = ()=> new Promise(resolve =>{
setTimeout(() => resolve ('first ()'), 1000);
});
const second () => new Promise (resolve => { 
setTimeout(() => resolve('second ()'), 1000);
});
const third =() => new Promise(resolve -> {
setTimeout(() => resolve('third ()'), 1000);
});

//First Apporach -->Asynchronous

Promise.all([first(), second (), third (),(someKey:someValue }]}
.then((data) => {
console.log("success:", data);
})
.catch((err) => {
console.log("error:", err);
})

//Second Approach -->Synchronous

const process = async () => {
const first await a();
const second = await b();
const third = await c();

return [first, second, third];	
};

process
	.then((data)=>{
	console.log("success:",data);
	})
	.catch((err)=>
	{
		console.log("error:",err);
	})
```
 Introduction to Express
 ------
 
  Routing Logic
  ```Javascript
  Return Different response data based on different request URL’s

 {
 case "/name":
 res.end('Http Server response : Mrigesh Deshpande);
 break;
 case "/company":
 res.end('Http Server response : A reputed MNC');
 break;
 default:
 res.end('Http Server response : Incorrect
endpoint!');
 }
 ```
 How we need to write redundant code which is not extensible to add new route everytime
 ![image](https://user-images.githubusercontent.com/67750918/183666988-653aa36b-2a66-4fa4-a849-052282f37053.png)

Express JS to rescue ->
![image](https://user-images.githubusercontent.com/67750918/183667159-8d426fa2-5b3b-4cbd-b9b8-85dfeac4af30.png)

Express.js Features
------
● Fast and simple server side development

● Access to middleware

● Routing

● Templates

```Javascript
	var expressJs = require("express");
	var expressApp = expressJs();
	// Add routing logic
	expressApp.get("/", function(request, response){
	 response.send("ExpressJs backed https endpoint is ready!!!");
	 });
	//Ask app to listen on given a port
	expressApp.listen(8000, function(){
	 console.log("Application is listening to port 8000");
	 });
	 
```
![image](https://user-images.githubusercontent.com/67750918/183668202-d1550809-38fb-4662-9cc4-68547243bae6.png)

Understanding express
------
1. Import modules and create express app

2. expressApp.get() helps us respond to get requests.

3. expressApp.listen() helps us listen to a particular code

Let us now add multiple routes using Express and test it

```Javascript
expressApp.get("/", function(request, response){
 response.send("ExpressJs backed http endpoint is ready!!!");
 });
// Add routing logic
expressApp.get("/name", function(request, response){
 response.send("ExpressJs backed http endpoint is ready! Name : Tushar Raina");
 });
// Add routing logic
expressApp.get("/company", function(request, response){
 response.send("ExpressJs backed http endpoint is ready! Company : A reputed MNC");
 });
```

## Express Middleware

![image](https://user-images.githubusercontent.com/67750918/183668955-ca261e39-8b44-41c8-9c36-96899dad6716.png)

What can Middlewares can handle

1. Logging

2. Sending Static Files

3. Authentication and Authorisation

4. Session Management

5. Parsing

6. Rate Limiting

How do middlewares work?
------
1. Each middleware has access to request , response and
next() method

2. Each of them can terminate the flow

3. Ultimately we get a graph like structure which keeps our
code modular and simpler
![image](https://user-images.githubusercontent.com/67750918/183669248-d4ed0d50-0a85-402b-82e6-ed05745f8a4d.png)

Common Express middlewares
------

1. Morgan
2. Helmet
3. Body-Parser
4. Cors
5. Express rate Limit


 ## Model View Controller
 
 What is MVC
 ------
The Model-View-Controller is an architectural pattern that separates an application
into three main logical components: the model, the view, and the controller. This is
used in combination with the front end and back end. Each of these components is
built to handle specific development aspects of an application. MVC is one of the
most frequently used industry-standard web development frameworks to create
scalable and extensible projects.

What is the model?
------
The Model component corresponds to all the data-related logic that the user works
with. This includes organising the data from the database in a presentable format
and sending it as a response. This can represent either the data transferred
between the View and Controller components or any other business logic-related
data. For example, a Customer object will retrieve the customer information from
the database, manipulate it, and update it back to the database or use it to render
data.

What is a view?
------
The View component is used for all the UI logic of the application. For example, the
Customer view will include all the UI components such as text boxes, dropdowns,
etc., that the final user interacts with.

What is the controller?
------
Controllers act as an interface between Model and View components to process all
the business logic and incoming requests, manipulate data using the Model
component, and interact with the Views to render the final output. For example, the
Customer controller will handle all the interactions and inputs from the Customer
View and update the database using the Customer Model. The same controller will
be used to view the Customer data.

![image](https://user-images.githubusercontent.com/67750918/183652609-e1eabde0-ac24-4afc-934e-6fcad8e38904.png)

Example of MVC
The car driving mechanism is another example of the MVC model.
● Every car consists of three main parts.
● The user interface's view includes gear lever, panels, steering wheel, brake, etc.
● The controller is the mechanism which is Engine
● The model means the storage, which is the Petrol or Diesel tank
Car runs from the engine take fuel from storage but only uses mentioned user
interface devices.

MVC using Node and Express
------
• We can have a basic approach to work with nodes and express while building an
MVC. Now let’s try to clarify why using an MVC is useful and how it can turn your
standard Express/Node.js App into a high-level app just by wrapping around an
MVC Architecture.

• The code will contain only one home page and some templates. Here we are
trying to create a login app with the MVC architecture. This is an example to give
clarity around how it works.

• Since the Architecture comprises three main parts (Controller, Model, and View)
so under the src/ folder, we need to have the other subparts in different folders

Data Modelling
------
The Model-Viewer-Controller is a dominant paradigm for application development.
The MVC approach separates key common concerns for organized, manageable
application code.

The model classes represent domain-specific data and business logic in the MVC
application. It represents the shape of the data as public properties and business
logic as methods. 

## What is ORM?

Object-relational mapping is the process of mapping between objects and relational
database systems. Multiple databases use data in different ways, and
object-relational mapping maintains objects when the sources and app they access
can change with time. ORM is used to handle the passage of data between different
databases.

Why do we need ORM?
------

ORM helps to implement the principle of Do Not Repeat Yourself.
It helps with marshalling. ORMs generally allow fetching complete objects from the
database rather than row objects to wrap yourself.

Routing in Express
------

Routing is very crucial. It defines the URL structure that can be used to
interact with the web application.
Express apps use routers that are containers for a bunch of middleware. The
middleware holder can be used on a certain route, which enables to place the logic
in separate files and bring them together. 

Setting up Database
------

You can install MySQL client and Sequelize by executing the following command:
 npm install sequelize mysql2
Then we can add a models directory with a file called index.js, which will contain the
database and Sequelize.js setup.

First, we include the modules that we’re going to use:

• Sequelize allow us to create a new Sequelize instance and connect to the db

• We also define a User model and add it into our db object to make it accessible outside.

• require("./User.js")(sequelize, Sequelize)

• The db object which corresponds to the database is exported, and it corresponds to the database
methods for each model. We can access it when we want to fetch the data from the database.


## ORM :Object Relational Mapping

ORM stands for Object Relational Mapping, and is popular among the Object oriented programming
developers. It's a technique that performs the mapping of the software objects into the tables of a
database. So developers can interact with these objects to perform the CRUD operations rather than
writing the sql queries.

Working
------
ORM creates a model using the OOP providing a high level of abstraction. Mapping describes the
relationship of these objects to the database. Once the model is created it can be used to establish
the connection between the application and the sql code that is needed to manage the data

Advantage:
------
We now know that ORM minimizes the amount of knowledge needed to write the sql by automatically
generating the sql code still there are three major advantage of using it:
1. Application Designing : A well written ORM will force the developer to follow the best practice of
application designing.

2. Productivity : Since now the developer need not to focus much on the data access code which
used to be time consuming, developers can save their development time and can focus more on
the business logic.

3. Reduced Testing Time : Negligible amount of time will be needed to test the data access code
as the code generated by the ORM is already tested. 

Types of ORM:
------
Few of the popular ORM’s used in the market alongside nodejs are:

1. NodeORM: It's an ORM that works with MySQL, SQLlite and PostgresSQL

2. Prisma2 : It's an open source ORM used for Nodejs and Typescript and works with databases
such as MySQL, PostgresQL and SQLite.

3. Sequelize: Promise based ORM module used for NodeJS and works with databases such as
PostgreSQL, MySQL, SQLite, MSSQL and MariaDB


## Sequelize
Sequelize is a modern TypeScript and Node.js ORM for Postgres, MySQL, MariaDB, SQLite and SQL Server, and more. Featuring solid transaction support, relations, eager and lazy loading, read replication and more.

### Installation

Make sure you have Sequelize installed. Then install the Sequelize CLI to be used in your project with

```Javascript
npm install --save-dev sequelize-cli
```

And then you should be able to run the CLI with

```Javascript
npx sequelize --help
```

Usage
```Javascript

Sequelize CLI [Node: 10.21.0, CLI: 6.0.0, ORM: 6.1.0]

sequelize <command>

Commands:
  sequelize db:migrate                        Run pending migrations
  sequelize db:migrate:schema:timestamps:add  Update migration table to have timestamps
  sequelize db:migrate:status                 List the status of all migrations
  sequelize db:migrate:undo                   Reverts a migration
  sequelize db:migrate:undo:all               Revert all migrations ran
  sequelize db:seed                           Run specified seeder
  sequelize db:seed:undo                      Deletes data from the database
  sequelize db:seed:all                       Run every seeder
  sequelize db:seed:undo:all                  Deletes data from the database
  sequelize db:create                         Create database specified by configuration
  sequelize db:drop                           Drop database specified by configuration
  sequelize init                              Initializes project
  sequelize init:config                       Initializes configuration
  sequelize init:migrations                   Initializes migrations
  sequelize init:models                       Initializes models
  sequelize init:seeders                      Initializes seeders
  sequelize migration:generate                Generates a new migration file      [aliases: migration:create]
  sequelize model:generate                    Generates a model and its migration [aliases: model:create]
  sequelize seed:generate                     Generates a new seed file           [aliases: seed:create]

Options:
  --version  Show version number                                                  [boolean]
  --help     Show help                                                            [boolean]

Please specify a command
```

Without Sequelize
------
```Javascript

> CREATE DATABASE ecom_db;
> USE ecom_db;
> CREATE TABLE `Categories` (
 `ID` int NOT NULL AUTO_INCREMENT,
 `Name` varchar(255) NOT NULL,
 `Description` varchar(255) NOT NULL,
 `CreatedAt` datetime DEFAULT CURRENT_TIMESTAMP,
 `UpdatedAt` datetime DEFAULT CURRENT_TIMESTAMP,
 PRIMARY KEY (`ID`)
)
```
With Sequelize
------
```Javascript
const Category = sequelize.define("category", {
 id: {
 type: Sequelize.INTEGER,
 primaryKey: true,
 autoIncrement: true
 },
 name: {
 type: Sequelize.STRING,
 allowNull: false
 },
 description: {
 type: Sequelize.STRING
 },{
 tableName: 'categories'
 /**
 * This helps you to provie a custom name to the table
 * If above is not provided, model name is converted into
plural and set as the table name
 *
 * If we want to just use the model name provided, we can
provide the below option :
 *
 * freezeTableName: true
 */
 });
 return Category;
```

```Javascript
	const Sequelize = require("sequelize");
	const sequelize = new Sequelize(
	 ‘ecom_db’,
	 ‘root’,
	 ‘password’, {
	 host: localhost,
	 dialect: mysql,
	 operatorsAliases: false,
	 pool: {
	 max: 5,
	 min: 0,
	 acquire:30000,
	 idle: 10000 } } );
```
where:
1. Host: is the ip of the system where the database is located. Currently its on local system so its
set to `localhost`

2. dialect: It specifies the connector library that will be used by the sequelize for the database.
Since we are working with MySQL we specify ‘mysql’

3. operatorAliases: It is a flag that allows a specific symbol operator. Ideally we should use
sequelize without any aliases as it improves the security, therefore we have set the flag to false.
Few of the default alias that sequelize uses are $eq, $ne, $lte,$gt,$lt, etc.

4.Pool: It contains the parameter of the connection pool between the application and the
database that is created while initializing the sequelize. When the connection to the database is
made from more than one process then we might have to create more number of instances in
each process. But in each instance we have to define a maximum connection for the pool size
so that the total pool size is met for each instance. For eg. If we need to create a max
connection pool size of 60 and in total we had 6 process then the Sequelize instance of each
process should have a maximum of size 10 connection pool.

Max and min are used to define the threshold for such number of connection pool size.
5. Acquire: max time in ms that a pool will try to get connection before throwing error for that
instance of Sequelize.

6. idle: max time in ms that a pool will stay idle before releasing the connection.

Benefits of Sequelize:
------

Lets summarize the advantage of sequelize:
1. Helps in writing less and consistent code
2. Avoid SQL queries in most of the cases
3. Abstracts database engine

## Basic Model Querying Techniques

INSERT
------
● Syntax:

`Model.create()`
```Javascript
● Sequelize command:

Category.create({name:’Electronics’, description:`Product Descriptions`})
● Sql command:

Insert into Category(‘name’,’descriptions’) values (‘Electronics’,’Product Descriptions’)
```
```Javascript
● Sequelize command:

Category.create({name:’Electronics’,description:`Product Descriptions`},{fields:[name]})

● Sql command:

Insert into Category(‘name’) values (‘Electronics’)
```

SELECT
------
```Javascript
To select all the records from the table we can use the .findAll() function.

Syntax:
Model.findAll()

Suppose we have to find all the records of category table then we can run the following command:
Category.findAll()

To select a specific record from the model we can populate the `attributes` argument of `findAll()`
function as:
Syntax:
Model.findAll({attributes:[‘col1’,’col2’,[‘col3’, `column3`]]});

Here we are selecting the values of col1, col2 and col3 from the table.
[‘col3’, `column3`] will rename the col3 as column3 while returning the value.
````

## Aggregation:

```Javascript
To perform any aggregation such as count,max, min, etc. while working with findAll we can use
sequelize.fn function.
Suppose we have to count the number of categories in the category table:
Category.findAll(attributes:[[sequelize.fn(‘COUNT’,sequelize.col(‘id’)),’
num_category’]])
Similar sql function for the same would be:
Select count(id) as num_category from Category
```

Where clause as we know is used to perform the filtration in the search query.
```Javascript
	

Syntax:
	Model.findAll({
	where:{
	attribute_nam
	e:value } })
	
	Which is equivalent to the following sql query: Select * from . . . where attribute_name = value
```
```Javascript
Suppose we need to find out the category from the category table whose id is either 2 or 5 then that
can be done by running either of the following commands:
	category.findAll({
where:{
[Op.or]:{
 id:2,
 id:5
}
})

```

UPDATE
------
```Javascript
To update the value of the record in the database we can use the .update function
Syntax:
Model.Update({atrrib_1:val_1},
{
where:{
attrib_1:null
}
})
It means that set the value of attrib_1 to val_1 where the value of attrib_1 is null
```

DELETE
------
```Javascript
To delete a record from the table, or to truncate the table we can use the .destroy function of
sequelize along with the where clause as follow:
Syntax:
Model.destroy({
 where:{
 attrib:val } })
To delete the record with `attrib` as `val`
To truncate the table one can set the truncate flag of destroy function:
Model.destroy({
truncate:true });
```
Associations
------
The standard three associations that is, one to one, one to many and many to many is supported by
the sequelize. The only thing is that there are four different functions that are used to form either of
these three associations. Such functions are:
1. HasOne
2. Belongs to
3. HasMany
4. BelongstoMany
Suppose we have two models(tables) A & B then the formation of the associations using the above
forms are as follows:

One-to-One association is formed by combining the hasOne and belongsTo
Syntax:
A.hasOne(B,{/* options */});
 A.belongsTo(B);
 
One-to-Many association is formed by combining the hasMany and belongsTo
Syntax:
```
A.hasMany(B,{/* options */});
A.belongsTo(B);
 ```
 
● Many-to-Many association is formed by combining two belongs to many.
Syntax:
 ```
A.belongsToMany(B,{/* options */});
A.belongsToMany(B);
 ```
 
 
